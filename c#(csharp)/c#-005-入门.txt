复杂数据类型
变量的本质 是内存中占位
复杂数据类型特点 一般是多个数据集合 在一起构成的数据
一般可以自己取名字 ,可以自定义数据
枚举
被命名的整数常量的集合

申明枚举 
相当于创建一个自定义的枚举类型
和申明枚举变量
使用申明的自定义枚举类型 创建一个枚举变量

申明枚举的语法
enum E_自定义枚举名 
{
    自定义枚举项名字 = 5 , //枚举中包裹的整形常量是0,下面会依次累加
    1,                      //注意:值会在上一个累加 ,
    2,
    3
}
在申明地方申明枚举
namespace语句块中(常用)
class语句块
或者结构体
枚举不能在函数里申明

枚举的使用
申明枚举变量
E_playType 自定义名 = E_playType. 这里只会出现在namespace中申明的自定义枚举名称
自定义枚举类型 变量名 = 默认值;
一般情况与Switch使用
 
 枚举的类型转换
枚举与int 
括号强转
枚举与string
= (E_playType)enum.parse(typeof (E_playType),"");

枚举的作用 
在game开发中 对象会有很多状态 ,
可能会,,,
数组
任意变量类型顺序存储的数据集合

一维数组

数组的申明
变量类型[] 数组名; //只是申明数组,没有开房内存空间,没有初始化

变量类型 [] 数组名 = new 变量类型 [数组的长度];
//这种方法相当于 开了5个房间 ,但是房间里面的int值 默认为1;

变量类型[] 数组名 = new 变量类型 [数组的长度]{内容一,,};

变量类型 []数组名 = new 变量类型 []{内容1,内容2};//后面的内容就决定了数组的长度房间数

变量类型[] 数组名 = {内容1,内容2,}; //后面的内容就决定了数组的长度房间数

数组使用

1.数组的长度
console.writeline (array.length);

2.获取数组中的元素
数组的下标和索引 是从零开始的
一定注意 不能超越 界限 即为长度减一
console.writeline (array[0]); //第一位

3.修改数组中的元素
array[0] = 99;

4.遍历数组
通过循环快速获取数组中的每一个元素
for (int i= 0; i<array.length;i++){
    console.writeline(array[i]);
}
5.增加数组的元素
数组初始化不能直接添加元素,直接搬家
for (int i= 0; i<array.length;i++){
    array2[i] = array[i];
}
array = array2;

6.删除数的元素
不能直接删除元素,继续搬家

7.查找数组的元素
只有遍历 才能确定是否存储了一个目标目录

所有的变量类型都能申明为数组,用于批量存储游戏同一类型对象的容器

二维数组
使用两个下标或者索引来确定的数组
行标,列标

申明
变量类型[,] 二维数组变量名 ;
int[,]arr;
变量类型 [,] 二维数组变量名 = new 变量类型 [行,列];

变量类型[,] 二维数组变量名 = new 变量类型 [行,列]{第0行内容},{第一行内容};

直接声明内容,不写死

直接等于声明

二维数组的使用
int[,] array = new int [,] {{1,2,3},{1,23,45}}; 获取长度
console.writeline(array.getlength(0));
console.writeline(array.getlength(1));
获取数组中的元素
换成坐标一样

遍历数组
for (int i= 0 ;i<array.getlength(0);i++){

    for(int j =0 ; j<array.getlength(1);j++)
    {
        array[i,j] //输出打印
    }

}
修改数组中的元素
和一维一样

增加数组的元素
和一维一样
删除数组的元素
和一维一样
查找数组中的元素
尼玛
游戏中一般用来存储矩阵 ,再控制台小游戏可以用二维数组表示地图格子

交错数组
略

值类型与引用类型的区别
值类型
其他类型 结构体
在相互赋值时,把内容拷贝给对方,它变我不变 
引用类型 
string 数组 类
相互赋值 是让两者指向同一个值 ,它变我也变
为什么有区别
因为二位存储方式区别
值类型存储在栈空间   系统分配 自动回收 , 小而快
引用类型 存储在堆空间  手动申请和释放 ,大而慢
注意:数组new 开了新的堆空间,与之前的无关

特殊的引用类型string 

string 它变我不变
string非常特殊,具备值类型的特征

重新赋值会在堆空间重新分配空间
缺点 频繁改变string重新赋值 会产生内存垃圾
需要优化替代方案

通过断点监视 
&string1 栈内存地址

函数(方法)
1.封装的代码块
2.提升代码复用率
3.抽象行为
是封装代码进行重复使用的一种机制
函数写在class里
        struct里
static 返回类型 函数名 (参数类型,参数名1,参数类型,参数名2){
    函数的代码逻辑
    return 返回值;
    (如果需要返回值才返回)
}
void 没有返回值 返回类型可以是任意变量类型
函数名使用帕斯卡命名法
参数不是必须的,可以有0-n个参数,参数的类型也可以是任意类型

参数名 驼峰命名法 多个参数,需要逗号隔开
当返回值不是void 必须通过新的关键字 return返回对应类型的内容 (即使是void也可以选择性使用return)

使用 
有参无参有返回值无返回值


直接写函数名(参数)

参数可以变量常量 函数
return后面可以写一个表达式 只要这个表达式的结果和返回值是一致的就行
函数的返回值一定是一个类型 只能是一个内容

关于return ,可以直接不执行之的代码,直接返回到函数外部

ref与 out
可以解决函数内部改变外部传入的内容,里面变了,外面也要变

函数参数修饰符
当传入的值类型参数在内部修改时,或者引用类型参数在内部重新申明时 外部的值会发生变化

static void changeValueRef(ref int value){
    value = 3;
}
传入也要加ref out
区别,ref传入的变量必须要初始化 out 不用
out传入的变量必须在内部赋值 ref 不用

变长参数
关键字 params 
static int sum (params int []arr){

}
意味可以传入n'个参数 n可以等于0 ,传入的参数会存储在arr数组中
函数参数可以有别的参数和params 关键字修饰的参数
函数参数中只能最多出现一个params关键字 并且一定是在最后一组参数前面可以有n个其他参数

默认参数

有参数默认值的参数,一般成为可选参数
作用 当调用函数时可以不传入参数,不传就会使用默认值作为参数的值
注意:支持多参数默认值,每一个参数都可以有默认值
如果要混用 ,可选参数 必须写在普通参数后面

函数重载
在同一语句块中
函数方法名相同 参数的数量 类型或者顺序有1不同
作用 命名一组功能相似的函数 减少函数名的数量 避免命名空间 的污染
提升程序可读性
ref 和 out也是可以重载

递归函数
函数自己调用自己
static void fun(){
    fun();
}
一个正确的递归函数必须有结束调用的条件
                用于条件判断的条件必须改变 能够产生停止的目的
结构体
任意变量的数据集合 ,可以自定义
是数据和函数的集合
在结构体中 可以申明各种变量和方法
用来表现存在关系的数据集合
语法
一般写在namespace语句块中
结构体的关键字 struct
struct 自定义结构体名 {
    struct Student {
    第一部分变量//在结构体中声明的变量不能直接初始化,变量类型 可以写任何类型 包括结构体 但是 不能是自己的结构体
 public    int age ;
            bool sex;
    第二部分 构造函数

没有返回值 函数名称必须与结构体相同 必须有参数 
如果申明了构造函数 ,必须有参数
public Student(int age ,bool sex ,string1 name)
{
        //新的关键字 this
        this.age = age ;
        this.sex = sex;
        //构造函数一般是为了在外部方便参数初始化的
}
    第三部分 函数 //表现数据结构的行为
    在结构体中的方法不需要加static
 public   void  Speak ()
    {
        console.writeline("nima{0},age");
    }
    //结构体命名的规范是帕斯卡命名法
    }
}
访问修饰符 修饰结构体中的变量与方法 是否可以被外部访问
public 公共的  可以被外部访问
private 私有的 只能内容中使用 默认 


结构体在函数中使用
Student s1;
s1.age =10;
s1.Speaka();
//构造函数 
Student s2 = new Student(18,true,2,"xiaohong");